<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Bootstrap Navbar Sidebar - Fixed to Left or Right</title>
    <link rel="stylesheet"
          id="theme_link"
          href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.3.1/materia/bootstrap.min.css"/>
    <link rel="stylesheet" href="./css/navbar-fixed-right.min.css">
    <link rel="stylesheet" href="./css/navbar-fixed-left.min.css">
    <link rel="stylesheet" href="./css/docs.css">
    <script
            src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
            crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
            integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
            crossorigin="anonymous"></script>
    <script src="./css/docs.js"></script>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <style>
        pre {
            display: inline-block;
            background-color: black;
            border-radius: 3px;
            padding: 0.1em 0.2em;
            color: royalblue;
        }
        img {
            width: "10px";
            height: "10px";
        }
        div{
            font-size: large;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-primary fixed-top p-1 ">
        <a class="navbar-brand" href>CloudNativeAPP<br>(フロントアプリ編)</a>
        <div class="collapse navbar-collapse " style="line-height: 0.5em"> 
            <ul class="navbar-nav" >
                <li class="nav-item">
                    <a class="nav-link" href="#1">1.AWS環境準備</a>
                    <a class="nav-link" href="#2">2.プロジェクト作成</a>
                    <a class="nav-link" href="#3">3.backend実装</a>
                    <a class="nav-link" href="#4">4.bff実装</a>
                    <a class="nav-link" href="#5">5.view実装</a>
                    <a class="nav-link" href="#6">6.DockerHubへのプッシュ</a>
                    <a class="nav-link" href="#7">7.ECSクラスタ作成</a>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <h1 id="1">1.AWS環境準備</h1>
        <p>
            以下の構成でAWS環境を用意する。
            <br>
            <img class="img-fluid" src="image/aws-arch.jpg">
            <br>
            <table class="table">
                <tr>
                    <th>サービス名</th>
                    <th>説明</th>
                </tr>
                <tr>
                    <td>VPC</td>
                    <td>
                        <li>プライベートサブネットとパブリックサブネットを2つずつ作成する。(ALB起動に必要なため)</li>
                        <li>プライベートサブネットとパブリックサブネットを作成する。</li>
                        <li>パブリックサブネットのdefault gatewayにはInternet Gatewayを設定する。</li>
                        <li>プライベートサブネットのdefault gatewayにはNATインスタンスを設定する。</li>
                        <li>VPC内への通信はlocalをターゲットにする。</li>
                    </td>
                </tr>
                <tr>
                    <td>NATインスタンス</td>
                    <td>
                        <li>パブリックサブネット上でNATインスタンスを起動する。</li>
                    </td>
                </tr>
                <tr>
                    <td>ALB</td>
                    <td>
                        <li>プライベートサブネットとパブリックサブネットにALBを作成する。</li>
                        <li>各ALBのセキュリティグループでインバンドへのHTTP通信を許可する。</li>
                        <li>target groupにはインスタンスを指定する。(後でECSを構築する。)</li>
                    </td>
                </tr>
            </table>
            ※その他のAWSサービスはアプリケーションデプロイ時に設定する。
        </p>
        <h1 id="2">2.プロジェクト作成</h1>
        <p>
            以下2つのプロジェクトをSTSに作成する。
            <table class="table">
                <tr>
                    <th>プロジェクト名</th>
                    <th>説明</th>
                </tr>
                <tr>
                    <td>backend</td>
                    <td>バックエンドで稼働するアプリケーションのプロジェクト。SpringBoot on Dockerでプライベートサブネット上に起動する。</td>
                </tr>
                <tr>
                    <td>bff</td>
                    <td>フロントで稼働するアプリケーションのプロジェクト。SpringBoot on Dockerでパブリックサブネット上に起動する。</td>
                </tr>
            </table>
        </p>
        <p>
            手順は以下の通り。
            <ol>
                <li><a href src="https://start.spring.io/">Spring Initializr</a>で、プロジェクトを作成する。</li>
                <li>ダウンロードしたZIPファイルをフォルダに展開する。</li>
                <li>展開したフォルダ上で<code>mvn spring-boot:run</code>を実行し、ビルドが成功することを確認する。</li>
                <li>STSに既存Mavenプロジェクトとしてインポートする。</li>
                <li>pom.xmlに必要なライブラリを追記する。</li>
                <li>ExcutableJar形式でビルドする場合は以下をpom.xmlに追記する。</li>
            </ol>
        </p>
        <p>
            STS上にプロジェクト作成後、GitHubにコミットする。
            <ol>
                <li>GitHub上にリポジトリを作成する。</li>
                <li>以下コマンドを実行</li>
                <pre><code>
        git init
        echo "# Study CloudNative Webapp" >> README.md
        git add .
        git commit -m "first commit"
        git remote add origin git@github.com:yushin1402/aws-cloudnative-webapp.git
        git push -u origin master
                </code></pre>
                <li>docsフォルダをGitHub Pagesで公開する。</li>
            </ol>
        </p>
        <h1 id="3">3.backend実装</h1>
        <p>
            「/api/v1/users」でリクエストを受け付け、ユーザのリストを返却するアプリケーションを実装する。
        </p>
        <p>
            <ol>
                <li>パッケージを作成する。</li>
                <table class="table">
                    <tr>
                        <th>パッケージ名</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>com.example.backend.app.model</td>
                        <td>Modelクラスを配置する。</td>
                    </tr>
                    <tr>
                        <td>com.example.backend.app.web</td>
                        <td>Controllerクラスを配置する。</td>
                    </tr>
                    <tr>
                        <td>com.example.backend.config</td>
                        <td>アプリケーション設定を定義したクラスを配置する。</td>
                    </tr>
                </table>
                <li>Modelクラスの実装</li>
                ユーザ情報を定義するクラスを実装する。
                <br>
                <pre><code>
        package com.example.backend.app.model;

        import lombok.AllArgsConstructor;
        import lombok.Builder;
        import lombok.Data;
        import lombok.NoArgsConstructor;
        
        @AllArgsConstructor
        @NoArgsConstructor
        @Builder
        @Data
        
        public class User {
            
            private String userId;
            private String userName;
        
        }                                                  
                </code></pre>
                <br>
                Lombokを利用してSpringBoot起動時にコードの自動生成を行っている。
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td><code>@AllArgsConstructor</code></td>
                        <td>
                            全てのプロパティ(<code>userId</code>と<code>userName</code></code>
                            を引数にしたコンストラクタを自動生成する。
                        </td>
                    </tr>
                    <tr>
                        <td><code>@NoArgsConstructor</code></td>
                        <td>
                            引数なしのコンストラクタを自動生成する。
                        </td>
                    </tr>
                    <tr>
                        <td><code>@Builder</code></td>
                        <td>
                            Builderクラスを自動生成する。Builderを利用することで、メソッドチェーンで値を設定できる。
                            この後実装するContoroller側での呼び出し方を見るとイメージがつく。<br>
                        </td>
                    </tr>
                    <tr>
                        <td><code>@Data</code></td>
                        <td>
                            getterやsetterなどを自動生成する。
                        </td>
                    </tr>
                </table>
                <li>Contorollerクラスの実装</li>
                Userオブジェクトを返却するAPIを作成する。
                <br>
                <pre><code>
        package com.example.backend.app.web;

        import java.util.ArrayList;
        import java.util.List;
        
        import org.springframework.web.bind.annotation.GetMapping;
        import org.springframework.web.bind.annotation.RequestMapping;
        import org.springframework.web.bind.annotation.RestController;
        
        import com.example.backend.app.model.User;
        
        @RestController
        @RequestMapping("/api/v1")
        public class BackendRestController {
        
            @GetMapping("/users")
            public List<User> getUsers(){
                List<User> users = new ArrayList<>();
                users.add(User.builder().userId("1").userName("Taro").build());
                users.add(User.builder().userId("2").userName("Jiro").build());
                return users;
            }
        
        }                                                                           
                </code></pre>
                <br>
                「/api/v1/users」でリクエストに対して、Userオブジェクトを返却している。
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td><code>@RestController</code></td>
                        <td>
                            RestfulAPIを作成する際に利用するアノテーション。
                            戻り値をJSONオブジェクトへの変換を行っている。<br>
                            (<code>@Controller</code>とすればViewが返却される。)
                        </td>
                    </tr>
                    <tr>
                        <td><code>@RequestMapping("/api/v1")</code></td>
                        <td>
                            メソッドと「/api/v1」URLのマッピング定義をしている。
                        </td>
                    </tr>
                    <tr>
                        <td><code>@Builder</code></td>
                        <td>
                            Builderクラスを自動生成する。Builderを利用することで、メソッドチェーンで値を設定できる。
                            この後実装するContoroller側での呼び出し方を見るとイメージがつく。<br>
                        </td>
                    </tr>
                    <tr>
                        <td><code>User.builder()</code></td>
                        <td>
                            Userクラスの<code>@Builder</code>で定義したBuilderメソッドを呼び出している。
                            Userクラスのプロパティをメソッドチェーンで呼び出し、値を設定している。
                        </td>
                    </tr>
                </table>
                <li>SpringBoot起動クラスの実装</li>
                SpringBootを起動する際に呼び出す起動クラスを実装する。
                このクラスはSpringBootプロジェクトを作成した際にデフォルトでトップパッケージに存在するが、
                分かりやすさの観点で、com.example.backend.config配下に作成する。
                <br>
                <pre><code>
        package com.example.backend.config;

        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
        import org.springframework.context.annotation.ComponentScan;
        
        @SpringBootApplication
        public class BackendApplication {
        
            public static void main(String[] args) {
                SpringApplication.run(BackendApplication.class, args);
            }
        
        }                                                                        
                </code></pre>
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td><code>@SpringBootApplication</code></td>
                        <td>
                            SpringBootの起動クラスであることを宣言するアノテーション。
                            com.example.backend.config配下に<br>
                            <code>@SpringBootApplication</code>を宣言することで、
                            コンポーネントスキャンの対象がcom.example.backend.config以下の階層に限定される。<br>
                            従って、com.example.backend.app配下のクラスで
                            Bean定義を行ってもDIコンテナにBean登録されないため注意すること。<br>
                            デフォルトのプロジェクトではトップパッケージに<code>@SpringBootApplication</code>
                            が配置されているため、<br>
                            全てのクラスでBean定義が可能だが管理が煩雑になるため、com.example.backend.configに<br>
                            Bean定義を行うクラスをまとめて管理する方針としている。
                        </td>
                    </tr>
                </table>
                <li>WebMVC設定クラスの実装</li>
                backendアプリケーションをWebMVCとして動作させるための設定クラスを実装する。
                <br>
                <pre><code>
        package com.example.backend.config;
        
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
        
        @Configuration
        @ComponentScan("com.example.backend.app.web")
        
        public class MvcConfig implements WebMvcConfigurer {
        
        }                                                                              
                </code></pre>
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>com.example.backend.configへの配置</td>
                        <td>
                            このパッケージに配置することでSpringBoot起動時の起動クラス(BackendApplication)によるコンポーネントスキャン対象となる。
                        </td>
                    </tr>
                    <tr>
                        <td><code>@Configuration</code></td>
                        <td>
                            このアノテーションによりConfigurationクラスであることを宣言する。サンプルコードからは読み取りづらいが、
                            クラス内にインスタンスを返す<code>@Bean</code>を付与したメソッドを定義すると、Bean定義を行うことが出来る。
                        </td>
                    </tr>
                    <tr>
                        <td>
                          <code>@ComponentScan("com.example.backend.app.web")</code>
                        </td>                       
                        <td>
                            引数を指定することで特定のパッケージやクラスをDIすることが出来る。com.example.backend.app.webをDIし、SpringBoot起動時にControllerの
                            <code>@RestContoroller</code>や<code>GetMapping</code>メソッドをDIし、APIの受け口を作成している。
                            DIされたインスタンスは、<code>WebMvcConfigurer</code>のdefaultメソッドで利用されていると思慮。
                        </td>
                    </tr>
                </table>
                <li>application.ymlの設定</li>
                バックエンドアプリケーションのコンテキストはこのファイルで設定する。
                <br>
                <pre><code>
        server:
            servlet:
              context-path: /backend                  
                </code></pre>
            </ol>
        </p>
        <h1 id="4">4.bff実装</h1>
        <p>
            index.htmlのボタンを押下し、APIを呼び出すBFFを作成する。
        </p>
        <p>
            <ol>
                <li>パッケージを作成する。(backendと同様の構成)</li>
                <table class="table">
                    <tr>
                        <th>パッケージ名</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>com.example.backend-for-frontend.app.model</td>
                        <td>Modelクラスを配置する。</td>
                    </tr>
                    <tr>
                        <td>com.example.backend-for-frontend.app.web</td>
                        <td>Controllerクラスを配置する。</td>
                    </tr>
                    <tr>
                        <td>com.example.backend.config</td>
                        <td>アプリケーション設定を定義したクラスを配置する。</td>
                    </tr>
                </table>
                <li>Modelクラスの実装</li>
                ユーザ情報を定義するクラスを実装する。backendからのレスポンスを格納するため、backendと同じ実装で問題ない。
                <li>Contorollerクラスの実装</li>
                この後実装するindex.htmlからの呼び出しに応じてbackendのAPIを呼び出し、レスポンスをmodelに格納してViewに返却する。
                <br>
                <pre><code>
        package com.example.backendforfrontend.app.web;

        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.stereotype.Controller;
        import org.springframework.ui.Model;
        import org.springframework.web.bind.annotation.RequestMapping;
        import org.springframework.web.bind.annotation.RequestMethod;
        import org.springframework.web.client.RestOperations;
        
        import com.example.backendforfrontend.app.model.User;
        
        @Controller
        public class BackendForFrontendController {
        
            @Autowired
            RestOperations restOperations;
        
            @RequestMapping(method = RequestMethod.GET, value="users")
            public String getUsers(Model model) {
                String service = "/backend/api/v1/users";
                model.addAttribute("users",
                        restOperations.getForObject(service, User[].class));
                return "users";
            }
        }
                </code></pre>
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td><code>RestOperations restOperations</code></td>
                        <td>
                            org.springframework.web.client.RestOperationsでbackendのAPIを呼び出している。<br>
                            DTOとレスポンスのバインドをよしなにやってくれるため、便利なライブラリとのこと。<br>
                            上記のソースでは、backendがUserオブジェクトをJSONで返却しているが、このキー値と<br>
                            <code>User.class</code>のプロパティを自動でマッピングし、格納している。
                        </td>
                    </tr>
                    <tr>
                        <td><code>@RequestMapping(method = RequestMethod.GET, value = "users")/code></td>
                        <td>
                            BFFの「/users」に対するGETリクエストを受け付けるとこのアノテーションを付与したメソッドが実行される。<br>
                            なお、先頭の"/"は省略可能ならしい。
                        </td>
                    </tr>
                    <tr>
                        <td>
                          <code>Model model</code>
                        </td>                       
                        <td>
                            <code>RequestMapping</code>の引数に設定された<code>Model model</code>はレスポンスとして<br>
                            View(=TymeLeaf)に返却されるので、addAttributeしておくと、View側で返却結果を画面に反映出来る。<br>
                            <code>return "users"</code>がTymeLeaf側でレスポンスを取得する際のキーとなる。                        
                        </td>
                    </tr>
                    <tr>
                        <td>
                          <code>String service = "/backend/api/v1/users";</code>
                        </td>                       
                        <td>
                            <code>String service</code>にbackendのURLを定義しているが、ホスト部はあえて記載していない。<br>
                            実環境ではホスト部はALBのDNS名となり、環境差分である。このため、application.ymlと<code>@ConfigurationProperty</code><br>
                            を駆使することで、プレフィックス定義として外だしする。
                        </td>
                    </tr>
                </table> 
                <li>application.ymlの設定</li>
                変数<code>service</code>にプロパティを定義する。
                <br>
                <pre><code>
        service:
          dns: http://internal-MA-saitoumsv-private-alb-1666952727.ap-northeast-1.elb.amazonaws.com
                </code></pre>               
                <li>ServicePropertiesクラスの実装</li>
                applicaion.ymlに定義したプロパティを取得するメソッドを実装する。
                <br>
                <pre><code>
        package com.example.backendforfrontend.app.web;

        import org.springframework.boot.context.properties.ConfigurationProperties;
        import org.springframework.stereotype.Component;
        
        @Component
        @ConfigurationProperties(prefix="service")
        public class ServiceProperties {
            
            private String dns;
        
        }                                                                                         
                </code></pre>
                <table class="table">
                    <tr>
                        <th>ポイント</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td><code>@Component</code></td>
                        <td>
                            環境差分がある設定はDIコンテナにBean登録することで、変更が用意になる。(今回はapplication.ymlの変更だけで対応可能)
                        </td>
                    </tr>
                    <tr>
                        <td><code>@ConfigurationProperties(prefix="service")</td>
                        <td>
                            このアノテーションを付与したプロパティには引数のprefixが定義される。(prefix以外も定義可能)
                        </td>
                    </tr>
                </table> 
                <li>MvcConfigクラスの実装</li>
                ServicePropertyでserviceにプレフィックスを付与する方法をとったが、この場合、URL自体はContorollerごとに実装しなければならない。<br>
                これを避けるために、SpringBoot起動時に<code>@Data</code>を付与したServicePropertiesをDIし、<br>
                <code>dns</code>の値を<code>RestOperation</code>に渡し、<code>rootUri</code>に<code>dns</code>の値を格納して<code>RestOperations</code>を<br>
                ビルドすることで、全てのURLを<code>ServicePropertis</code>にまとめて管理することができる。
                <br>
                <pre><code>
        package com.example.backendforfrontend.config;

        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.boot.web.client.RestTemplateBuilder;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.client.RestOperations;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
        
        import com.example.backendforfrontend.app.web.ServiceProperties;
        
        @ComponentScan("com.example.backendforfrontend.app.web")
        @Configuration
        
        public class MvcConfig implements WebMvcConfigurer {
            @Autowired
            ServiceProperties properties;
            
            @Bean
            public RestOperations restOperations(RestTemplateBuilder restTemplateBuilder) {
                return restTemplateBuilder.rootUri(properties.getDns()).build();
            }
        
        }        
                </code></pre>
            </ol>
        </p>
        <h1 id="5">5.view実装</h1>
        <p>
            backendを呼び出すviewを実装する。viewにはThymeLeafを利用する。
            <ol>
                <li>index.htmlの実装</li>
                本アプリのトップ画面を表示するindex.htmlを作成する。<br>
                SpringBootにおいて、静的ファイルの格納パスは以下の通り定められている。
                <table class="table">
                    <tr>
                        <th>検索順番</th>
                        <th>格納パス</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>src/main/resources/META-INF/resources/</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>src/main/resources/</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>src/main/resources/static/</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>src/main/resources/public/</td>
                    </tr>
                </table>
                <p>
                    (※)各フォルダで同じ名前のHTMLファイルが存在する場合は、検索順番が
                    最も低いファイル(一番最初に検索されたファイル)が返却される。
                </p>

                <p>
                    src/main/resources/META-INF/resources/とsrc/main/resources/には設定ファイルも格納されているため、htmlファイルを格納するのは好ましくない。
                    今回はresources/static配下にindex.htmlファイルを格納する。<br>
                    index.htmlのコードは以下の通り。
                </p>
                <pre><code>
        &lt;!DOCTYPE html&gt;
        &lt;html lang="ja"&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
            &lt;title&gt;Index&lt;/title&gt;
            &lt;link rel="stylesheet" href="static/css/flex.css" media="(min-width: 1280px)"&gt;
            &lt;link rel="stylesheet" href="static/css/flex_mobile.css" media="(min-width: 320px) and (max-width: 767px)"&gt;
            &lt;link rel="stylesheet" href="static/css/flex_tablet.css" media="(min-width: 768px) and (max-width: 1279px)"&gt;
            &lt;link rel="stylesheet" href="static/css/index.css" media="(min-width: 1280px)"&gt;
            &lt;link rel="stylesheet" href="static/css/index_mobile.css" media="(min-width: 320px) and (max-width: 767px)"&gt;
            &lt;link rel="stylesheet" href="static/css/index_tablet.css" media="(min-width: 768px) and (max-width: 1279px)"&gt;
            &lt;script type="text/javascript" src="webjars/jquery/jquery.js"&gt;&lt;/script&gt;        
        &lt;/head&gt;
        &lt;body&gt;
        &lt;h1&gt;Hello! AWS ECS sample!&lt;/h1&gt;
        &lt;h2&gt;Please call backend service.&lt;/h2&gt;
        &lt;form id="form" action="users" method="get"&gt;
            &lt;button id="confrim" name="confrim" class="main-button" type="submit" value="Submit"&gt;Call backend service&lt;/button&gt;
        &lt;/form&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    </code></pre>
        <br>
        <table class="table">
            <tr>
                <th>ポイント</th>
                <th>説明</th>
            </tr>
            <tr>
                <td><code>action="users"</code></td>
                <td>URLパス(相対パス)を表す。backedn-front-endのコントローラ定義と
                    <br>合わせる必要がある。
                </td>
            </tr>
            <tr>
                <td><code>method="get"</code></td>
                <td>
                    form送信する際のメソッドを定義。backend-for-frontendコントローラ定義と
                    <br>合わせる必要がある。
                </td>
            </tr>
        </table>
            <li>users.htmlの作成</li>
            <p>
                index.htmlからユーザ情報をフォーム送信したのち、backend-for-frontendとbackendにより処理された結果を
                htmlとして、ブラウザに返却する。このhtml(users.html)を作成する。users.htmlには、backend-for-frontendの
                返却オブジェクトを組み込むことで、ユーザ情報をページに反映する。
            </p>
            <pre><code>
        &lt;!DOCTYPE HTML&gt;
        &lt;html xmlns:th="http://www.thymeleaf.org" lang="ja"&gt;
        &lt;head&gt;
            &lt;title&gt;Hello! Thymeleaf&lt;/title&gt;
            &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
            &lt;link rel="stylesheet" href="static/css/flex.css" media="(min-width: 1280px)"&gt;
            &lt;link rel="stylesheet" href="static/css/flex_mobile.css" media="(min-width: 320px) and (max-width: 767px)"&gt;
            &lt;link rel="stylesheet" href="static/css/flex_tablet.css" media="(min-width: 768px) and (max-width: 1279px)"&gt;
            &lt;link rel="stylesheet" href="static/css/users.css" media="(min-width: 1280px)"&gt;
            &lt;link rel="stylesheet" href="static/css/users_mobile.css" media="(min-width: 320px) and (max-width: 767px)"&gt;
            &lt;link rel="stylesheet" href="static/css/users_tablet.css" media="(min-width: 768px) and (max-width: 1279px)"&gt;
            &lt;script type="text/javascript" src="webjars/jquery/jquery.js"&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;h1&gt;Hello! AWS ECS sample!&lt;/h1&gt;
        &lt;table&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;No&lt;/th&gt;
                &lt;th&gt;User ID&lt;/th&gt;
                &lt;th&gt;User Name&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            &lt;tr th:each="user, status : ${users}"&gt;
                &lt;td th:text="${status.count}"&gt;&lt;/td&gt;
                &lt;td th:text="${user.userId}"&gt;&lt;/td&gt;
                &lt;td th:text="${user.userName}"&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;/body&gt;
        &lt;/html&gt;
            </code></pre>
            <table class="table">
                <tr>
                    <th>ポイント</th>
                    <th>説明</th>
                </tr>
                <tr>
                    <td>配置場所</td>
                    <td>
                        backend-for-frontendが返却する戻り値を組み込んだhtmlは、SpringBootのビューテンプレートエンジンで生成する。
                        このため、users.htmlはsrc/main/resources/templates配下に作成しなければならない。
                    </td>
                </tr>
                <tr>
                    <td><code>tr th:each="user, status : ${users}"</code></td>
                    <td>
                        th:each属性はThymeLeafの繰り返し構文となる。構文は以下。<br>
                        <ul><code>th:each="変数名, ステータス変数名 : コレクション"</code></ul>
                        上記のコードでは繰り返し構文により、<code>${users}</code>(BackendForFrontendControllerクラスから渡されたmodel)
                        のエンティティ数分だけ、テーブルタグ内のtdタグを繰り返す処理となっている。なお、ステータス変数は、ThymeLeafが独自に持っているステータス情報で、
                        ${status.count}は現在の番号(繰り返しが何回目かの番号)を表示する。
                    </td>
                </tr>
            </table>
            </ol>
        </p>
        <h1 id="6">6.Dockerコンテナ作成/DockerHubへのプッシュ</h1>
        <p>
            前項までで実装したアプリをDockerコンテナ化し、DockerHubへプッシュする。
            <ol>
                <li>Dockerファイルの作成</li>
                <p>
                    backendプロジェクトとbackend-for-frontendプロジェクトそれぞれについて、Dockerファイルを作成する。<br>
                </p>
                    [backendプロジェクトDockerファイル]
                    <br>
                    <pre><code>
        # Dockerfile for sample service using embedded tomcat server
        FROM centos:centos7
        MAINTAINER yushin1402
        
        RUN yum install -y \
            java-1.8.0-openjdk \
            java-1.8.0-openjdk-devel \
            wget tar iproute git
        
        RUN wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo
        RUN sed -i s/\$releasever/6/g /etc/yum.repos.d/epel-apache-maven.repo
        RUN yum install -y apache-maven
        ENV JAVA_HOME /etc/alternatives/jre
        RUN git clone https://github.com/yushin1402/aws-cloudnative-webapp.git /usr/local/aws-cloudnative-webapp
        RUN mvn install -f /usr/local/aws-cloudnative-webapp/pom.xml
        RUN cp /etc/localtime /etc/localtime.org
        RUN ln -sf  /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
        EXPOSE 8080

        CMD java -jar -Dspring.profiles.active=production /usr/local/aws-cloudnative-webapp/backend/target/aws-cloudnative-webapp-backend-0.0.1-SNAPSHOT.jar
                    
                    </code></pre>
                    [backend-for-frontendプロジェクトDockerファイル]                    
                    <pre><code>
        # Dockerfile for sample service using embedded tomcat server

        FROM centos:centos7
        MAINTAINER debugroom
        
        RUN yum install -y \
               java-1.8.0-openjdk \
               java-1.8.0-openjdk-devel \
               wget tar iproute git
        
        RUN wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo
        RUN sed -i s/\$releasever/6/g /etc/yum.repos.d/epel-apache-maven.repo
        RUN yum install -y apache-maven
        ENV JAVA_HOME /etc/alternatives/jre
        RUN git clone https://github.com/yushin1402/aws-cloudnative-webapp.git /usr/local/aws-cloudnative-webapp
        RUN mvn install -f /usr/local/aws-cloudnative-webapp/pom.xml
        
        RUN cp /etc/localtime /etc/localtime.org
        
        RUN ln -sf  /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
        
        EXPOSE 8080
        
        CMD java -jar -Dspring.profiles.active=production /usr/local/aws-cloudnative-webapp/backend-for-frontend/target/aws-cloudnative-webapp-backend-for-frontend-0.0.1-SNAPSHOT.jar
                    </code></pre>
                    <p>
                        (※)Dockerコマンドの詳細は以下ページを参照
                        <br>
                        <a href src="https://qiita.com/FumiyaShibusawa/items/a0be39d28139a044157d">https://qiita.com/FumiyaShibusawa/items/a0be39d28139a044157d</a>
                    </p>
                    <table class="table">
                        <tr>
                            <th>ポイント</th>
                            <th>説明</th>
                        </tr>
                        <tr>
                            <td>ビルド処理概要</td>
                            <td>
                                <ol>
                                    <li>openJDKインストール</li>
                                    <li>Mavenパッケージダウンロード</li>
                                    <li>Mavenパッケージのバージョン変更(6に指定)</li>
                                    <li>Mavenインストール</li>
                                    <li>JAVA_HOME設定</li>
                                    <li>GitHubからプロジェクトをクローン</li>
                                    <li>Mavenビルド</li>
                                    <li>タイムゾーン設定ファイルバックアップ</li>
                                    <li>タイムゾーンを日本時間に変更</li>
                                    <li>コンテナリッスンポートを8080に設定</li>
                                    <li>ビルドしたMavenプロジェクトを実行</li>
                                </ol>
                            </td>
                        </tr>
                    </table>
                <li>GitHubへのプッシュ</li>
                <p>backendプロジェクトとbackend-for-frontendプロジェクトをGitHubにプッシュする。</p>
                <li>Dockerイメージ作成</li>
                <p>
                    Dockerインストール環境でDockerイメージを作成する。今回はVirtualBox上のCentOS7でDockerイメージを作成。(Dockerインストール作業の記載は割愛)
                    <ol>
                        <li>以下コマンドでCentOS上にGitをインストール</li>
                        <code>sudo yum -y install wget make gcc perl-ExtUtils-MakeMaker curl-devel expat-devel gettext-devel openssl-devel zlib-devel autoconf</code><br>
                        <code>sudo wget https://www.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz --no-check-certificate</code><br>
                        <code>sudo tar xvzf git-2.9.5.tar.gz</code><br>
                        <code>cd git-2.9.5</code><br>
                        <code>sudo make configure</code><br>
                        <code>sudo ./configure --prefix=/usr</code><br>
                        <code>sudo make install</code><br>
                        <code>git --version</code><br>
                        (※)最後にgitのバージョンが出力されていればOK<br>
                        (※)<code>sudo ./configure --prefix=/usr</code>については以下ページを参照。インストールディレクトリをmakeのコンフィグに定義しているらしい。(/usrは非推奨と書いてあるが。。。)<br>
                        <a href src="https://atmarkit.itmedia.co.jp/ait/articles/1107/01/news139.html">https://atmarkit.itmedia.co.jp/ait/articles/1107/01/news139.html</a>                        
                        <li>以下コマンドでGitHub上のプロジェクト取得</li> 
                        <code>sudo git clone https://github.com/yushin1402/aws-cloudnative-webapp.git</code><br>
                        <code>cd aws-cloudnative-webapp</code>
                        <li>以下コマンドでDOckerイメージを作成</li>
                        <code>docker build backend/ -t yushin1402/aws-cloudnative-webapp-backend:latests</code><br>
                        <code>docker build backend-for-frontend/ -t yushin1402/aws-cloudnative-webapp-backend-for-frontend:latests</code>
                        <br>
                        (2021/12/01 コメント①)<br>
                        以下のエラー出力によりDockerビルドエラーとなった。<br>
                        <code>Fatal error compiling: invalid target release: 11</code><br>
                        <ul>
                        MavenプロジェクトをJava11で作成していたのに対して、DockerfileではJava1.8を指定していたことが原因。以下の通り対応した。
                        <ol>
                            <li>pom.xmlの修正</li>
                            SpringBootの利用JavaとMavenビルドの利用Javaを1.8に修正した。
                            <br>
                            [SpringBootの利用Java(修正)]
                            <br>
                            <pre><code>
    	&lt;properties&gt;
    		&lt;java.version&gt;1.8&lt;/java.version&gt;
    	&lt;/properties&gt;
                            </code></pre>
                            <br>
                            [Mavenビルドの利用Java(追記)]
                            <br>
                            <pre><code>
        &lt;plugin&gt;
        	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        	&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        	&lt;configuration&gt;
        		&lt;source&gt;1.8&lt;/source&gt;
        		&lt;target&gt;1.8&lt;/target&gt;
        	&lt;/configuration&gt;
        &lt;/plugin&gt;
                            </code></pre>
                            <li>Dockerイメージの削除</li>
                            作成済みのDockerイメージにキャッシュが残っているため、以下コマンドで削除した。<br>
                            <code>docker rmi -f [イメージID]</code><br>
                            ※Dockerイメージはレイヤ管理されており、再作成すると差分のみ吸収される仕組みのため、
                              pom.xmlだけ修正しても生成済みのmavenプラグインのキャッシュは削除されない。<br>
                              (2021/12/01 コメント②)<br>
                              コメント①解決後、別のエラーが発生。<br>
                              <pre><code>
        [ERROR] com.example.backend.BackendApplicationTests  Time elapsed: 1.005 s  <<< ERROR!
        java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test
                              </code></pre>
                              <br>
                              Mavenビルド時に自動でテストコードが実行されるが、その際に<code>@SpringBootConfiguration</code>が記載されたコードを発見できず、起動クラスを特定できないエラーとなっている。
                              原因は、起動クラスをデフォルトのcom.eample.backend配下ではなく、com.example.backend.configに移動したこと。
                              この際、src/test/java配下のBackendApplicationTestsも併せて、src/main/javaと構成をそろえて、com.example.backend.configに移動する必要があった。
                              なお、Dockerビルド時にエラーが発生すると大幅な時間ロスとなるため、STS上で先にビルドテストをするべきだった。mavenビルドを選択し、Goalに「package」と設定して実行すると
                              jarパッケージのビルドをテスト出来る。
                            </ul>
                            </ol>
                        <li>以下コマンドで作成したDockerイメージをDockerHubへのプッシュする。</li>
                        <code>docker login</code><br>
                        <code>docker push yushin1402/aws-cloudnative-webapp-backend:latests</code><br>
                        <code>docker push yushin1402/aws-cloudnative-webapp-backend-for-frontend:latests</code>
                    </ol>
                </p>
            </ol>
            <h1 id="7">7.ECSクラスタ作成</h1>
            <p>
                Dockerコンテナを稼働させるECSクラスタを作成する。
                <ol>
                    <li>AWS ECSサービスからクラスタメニューを選択する。</li>
                    <li>クラスターの作成を押下する。</li>
                    <li>クラスターテンプレートの選択で、EC2+ネットワーキングを選択する。</li>
                    <li>クラスタの設定を行う。ポイントのみを以下に記載する。</li>
                    <table class="table">
                        <tr>
                            <th>設定項目</th>
                            <th>設定値</th>
                        </tr> 
                        <tr>
                            <td>パブリックIPの自動割り当て</td>
                            <td>クラスタにECSインスタンスを登録する際にパブリックIPが必要となるため、割り当てる。
                                (パブリックサブネットのデフォルトゲートウェイをインターネットゲートウェイに設定していたため、自動割り当てを無効にしても接続出来る認識だったが、上手くいかず。。。)</td>
                        </tr>
                        <tr>
                            <td>セキュリティグループ</td>
                            <td><ol>
                                <li>ECSクラスタを構成するEC2インスタンスに対するセキュリティグループに作業端末からのSSH、ALBからの通信を許可する。</li>
                                <li>ALBとの通信には動的ポーリングを利用するため、AKBにアタッチしたSGから32768 - 61000を許可する。</li>
                                <li>動的ポーリングを設定すると、クラスタ上のDockerコンテナに対して自動でポートを割り当て、ALBと接続するマッピング管理をECSがマネージドに行ってくれる理解。</li>
                                (2021/12/04 コメント)<br>
                                ECSインスタンス上のDockerコンテナの起動ポート番号が～十秒ごとにインクリメントされており、ALBがそのインクリメントを検知し、ルーティング先の
                                ポート番号を動的に変更している様子がターゲットグループのヘルスチェック画面から分かった。(この処理にどのような意味があるかは不明。。セキュリティ対策？)
                                <br>
                                <img class="img-fluid" src="image/aws-alb1.png">
                                <br>↑↑上記のヘルスチェック先ポートが～十秒おきに更新されているようが確認できた。
                            </ol></td>
                        </tr>
                    </table>
                    <li>ECSタスク定義を以下の通り行う。</li>
                    <ul><ol>
                        <li>ECSタスク実行用のIAMロール割り当て</li>
                        <p>
                            IAMサービス→ロール→ロールを作成→Elastic Container Service→ユースケースの選択→Elastic Container Serviceタスクを選択する。<br>
                            AmazonECSTaskExecutionRolePolicyを選択し、適当なロール名を指定して完了する。<br>
                            ロールは今後、必要に応じて追加していく方針とする。
                        </p>
                        <li>ECSの新しいタスク定義を作成する。起動タイプの互換性の選択はEC2を選択する。</li>
                        <li>dockerリポジトリの設定、リソース設定、ポートマッピング設定などを行う。ポートマッピングは動的ポーリングを行うためソースを0にする。宛先はSpringの8080ポートに設定する。</li>
                    </ol></ul>
                    <li>ECSサービス起動を以下の通り行う。</li>
                    <ul><ol>
                        <li>AmazonEC2ContainerServiceRoleを付与したIAMRoleを作成する。</li>
                        <p>
                            IAMサービス→ロール→ロールを作成→Elastic Container Service→ユースケースの選択→Elastic Container Serviceタスクを選択する。<br>
                            AmazonECSTaskExecutionRolePolicyを選択し、適当なロール名を指定して完了する。<br>
                            ロールは今後、必要に応じて追加していく方針とする。
                        </p>
                        <li>ECSの新しいタスク定義を作成する。起動タイプの互換性の選択はEC2を選択する。</li>
                        <li>dockerリポジトリの設定、リソース設定、ポートマッピング設定などを行う。ポートマッピングは動的ポーリングを行うためソースを0にする。宛先はSpringの8080ポートに設定する。</li>
                        <li>ECSメニューからクラスタを押下する。</li>
                        <li>作成したクラスタを指定する。</li>
                        <li>サービスタグの作成を押下する。</li>
                        <li>以下の通り設定する。</li>
                        <ul><ol type="a">
                            <li>起動タイプはEC2とする。</li>
                            <li>タスク定義は先ほど作成したもの</li>
                            <li>クラスタも先ほど作成したもの</li>
                            <li>サービス名は任意</li>
                            <li>サービスタイプはDAEMON(クラスタのインスタンス数に応じてコンテナが自動増減する。REPLICAは指定したタスクの数で固定数のコンテナ起動</li>
                            <li>タスクの数はコンテナの数を意味する。検証目的のため、1にする</li>
                        </ol></ul>
                    </ol></ul>
                    <li>起動後の確認を以下の通り行った。</li>
                    <ul><ol>
                        <li>ECSサービスの画面で、ECSが起動状態になっていること。</li>
                        <li>ECSインスタンスにログインし、環境上で挙動を確認した。</li>
                        <br>
                        [Dockerプロセス確認]
                        <br>
                        <pre><code>
            [root@ip-10-2-9-206 ecs]# docker ps
            CONTAINER ID   IMAGE                                                    COMMAND                  CREATED          STATUS                 PORTS                                         NAMES
            d4888957c145   yushin1402/aws-cloudnative-webapp-backend-for-frontend   "/bin/sh -c 'java -j…"   48 minutes ago   Up 48 minutes          0.0.0.0:49425->8080/tcp, :::49425->8080/tcp   ecs-MA-saitoumsv-ecstask-public-5-aws-cloudnative-webapp-bff-c2e987d8b2bcd8c1d301
                        </code></pre>
                        <br><br>
                        [コンテナログ]
                        <br>
                        <code><pre>
            [root@ip-10-2-9-206 ecs]# docker logs d4888957c145
            .   ____          _            __ _ _
           /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
          ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
           \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
            '  |____| .__|_| |_|_| |_\__, | / / / /
           =========|_|==============|___/=/_/_/_/
           :: Spring Boot ::                (v2.6.0)
          
          2021-12-04 22:55:30.130  INFO 1 --- [           main] c.e.b.c.BackendForFrontendApplication    : Starting BackendForFrontendApplication v0.0.1-SNAPSHOT using Java 1.8.0_312 on d4888957c145 with PID 1 (/usr/local/aws-cloudnative-webapp/backend-for-frontend/target/backend-for-frontend-0.0.1-SNAPSHOT.jar started by root in /)
          2021-12-04 22:55:30.133  INFO 1 --- [           main] c.e.b.c.BackendForFrontendApplication    : The following profiles are active: production
          2021-12-04 22:55:32.498  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
          2021-12-04 22:55:32.512  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
          2021-12-04 22:55:32.512  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.55]
          2021-12-04 22:55:32.626  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
          2021-12-04 22:55:32.626  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2386 ms
          2021-12-04 22:55:33.801  INFO 1 --- [           main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page: class path resource [static/index.html]
          2021-12-04 22:55:34.100  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
          2021-12-04 22:55:34.111  INFO 1 --- [           main] c.e.b.c.BackendForFrontendApplication    : Started BackendForFrontendApplication in 5.111 seconds (JVM running for 6.045)
          2021-12-04 22:55:44.488  INFO 1 --- [nio-8080-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
          2021-12-04 22:55:44.489  INFO 1 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
          2021-12-04 22:55:44.490  INFO 1 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
          2021-12-04 23:52:58.687  WARN 1 --- [io-8080-exec-10] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'POST' not supported]
          2021-12-04 23:58:36.755  WARN 1 --- [nio-8080-exec-5] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'POST' not supported]
                        </pre></code>
                        <br><br>
                        [ECSエージェントログ]
                        <br>
                        <code>/var/log/ecs/ecs-agent.log</code>にECSエージェントによるコンテナ起動ログが出力されている。ここを見るとDockerPullに失敗した、Dockerイメージからの起動に失敗した、そもそもECSインスタンスをクラスタに登録できていないなどのエラー原因の切り分けが出来る。
                        <br><br>
                        [ECSエージェント初期化ログ(あまり情報はないが、エージェントログに何もエラーがなかったら、初期化に失敗しているかも？)]
                        <br>
                        <pre><code>
        2021-12-04T10:56:51Z [INFO] pre-start
        2021-12-04T10:56:52Z [INFO] start
        2021-12-04T10:56:52Z [INFO] No existing agent container to remove.
        2021-12-04T10:56:52Z [INFO] Starting Amazon Elastic Container Service Agent
                        </code></pre>
                    </ol></ul>
                </ol>
            </p>
        </p>
    </div>
</body>
</html>
